using System;
using System.Collections.Generic;
using TlsCertificateLoader.Exceptions;
using TlsCertificateLoader.Models;

namespace TlsCertificateLoader;

/// <summary>
/// Represents a loader that allows one to generate and refresh a full chain <see cref="System.Security.Cryptography.X509Certificates.X509Certificate2Collection"/> and <see cref="System.Net.Security.SslStreamCertificateContext"/> for use with Kestrel.
/// </summary>
public sealed class TlsCertificateLoader
{
    private CertificateHolder _defaultCertificateHolder;
    private Dictionary<string, CertificateHolder> _additionalCertificateHolders;

    /// <summary>
    /// Constructor for <see cref="TlsCertificateLoader"/>
    /// </summary>
    /// <param name="defaultFullChainPemFilePath">The full path to the default full chain .pem file (e.g. the fullchain.pem generated by Certbot)</param>
    /// <param name="defaultPrivateKeyPemFilePath">The full path to the default private key .pem file (e.g. the privkey.pem generated by Certbot)</param>
    public TlsCertificateLoader(string defaultFullChainPemFilePath, string defaultPrivateKeyPemFilePath)
    {
        RefreshDefaultCertificates(defaultFullChainPemFilePath, defaultPrivateKeyPemFilePath);
    }

    /// <summary>
    /// Refresh the default certificate collection using different paths than previously provided.
    /// </summary>
    /// <param name="defaultFullChainPemFilePath">The full path to the default full chain .pem file (e.g. the fullchain.pem generated by Certbot)</param>
    /// <param name="defaultPrivateKeyPemFilePath">The full path to the default private key .pem file (e.g. the privkey.pem generated by Certbot)</param>
    public void RefreshDefaultCertificates(string defaultFullChainPemFilePath, string defaultPrivateKeyPemFilePath)
    {
        _defaultCertificateHolder = new(defaultFullChainPemFilePath, defaultPrivateKeyPemFilePath);
    }

    /// <summary>
    /// Refresh the default certificate collection using the same full file paths previously provided.
    /// </summary>
    public void RefreshDefaultCertificates()
    {
        if (_defaultCertificateHolder == null)
        {
            throw new DefaultCertificatesNotInitializedException();
        }
        _defaultCertificateHolder.RefreshCertificates();
    }

    /// <summary>
    /// Add additional certificate collections matched by hostname
    /// </summary>
    /// <param name="hostname">The hostname for which the certificate collection will be used</param>
    /// <param name="fullChainPemFilePath">The full path to the full chain .pem file (e.g. the fullchain.pem generated by Certbot)</param>
    /// <param name="privateKeyPemFilePath">The full path to the private key .pem file (e.g. the privkey.pem generated by Certbot)</param>
    public void AddAdditionalCertificates(string hostname, string fullChainPemFilePath, string privateKeyPemFilePath)
    {
        _additionalCertificateHolders ??= new(StringComparer.OrdinalIgnoreCase);
        _additionalCertificateHolders.Add(hostname, new(fullChainPemFilePath, privateKeyPemFilePath));
    }

    /// <summary>
    /// Remove an additional certificate collection
    /// </summary>
    /// <param name="hostname">The hostname for which the certificate collection was added</param>
    /// <returns><see langword="true"/> if the additional certificate is successfully found and removed; otherwise, <see langword="false"/>.</returns>
    public bool RemoveAdditionalCertificates(string hostname)
    {
        if (_additionalCertificateHolders == null)
        {
            throw new AdditionalCertificatesNotInitializedException();
        }
        return _additionalCertificateHolders.Remove(hostname);
    }

    /// <summary>
    /// Refreshes an additional certificate collection using different paths than previously provided.
    /// </summary>
    /// <param name="hostname">The hostname for which the certificate collection was added</param>
    /// <param name="fullChainPemFilePath">The full path to the full chain .pem file (e.g. the fullchain.pem generated by Certbot)</param>
    /// <param name="privateKeyPemFilePath">The full path to the private key .pem file (e.g. the privkey.pem generated by Certbot)</param>
    public void RefreshAdditionalCertificates(string hostname, string fullChainPemFilePath, string privateKeyPemFilePath)
    {
        if (_additionalCertificateHolders == null)
        {
            throw new AdditionalCertificatesNotInitializedException();
        }

        if (_additionalCertificateHolders.TryGetValue(hostname, out var certificateHolder))
        {
            certificateHolder.FullChainPemFilePath = fullChainPemFilePath;
            certificateHolder.PrivateKeyPemFilePath = privateKeyPemFilePath;
            certificateHolder.RefreshCertificates();
            return;
        }

        throw new AdditionalCertificatesNotFoundException(hostname);
    }

    /// <summary>
    /// Refreshes an additional certificate collection
    /// </summary>
    /// <param name="hostname">The hostname for which the certificate collection was added</param>
    public void RefreshAdditionalCertificates(string hostname)
    {
        if (_additionalCertificateHolders == null)
        {
            throw new AdditionalCertificatesNotInitializedException();
        }

        if (_additionalCertificateHolders.TryGetValue(hostname, out var certificateHolder))
        {
            certificateHolder.RefreshCertificates();
            return;
        }

        throw new AdditionalCertificatesNotFoundException(hostname);
    }

    internal CertificateHolder GetCertificateHolder(string hostname)
    {
        if (_additionalCertificateHolders != null && _additionalCertificateHolders.TryGetValue(hostname, out var certificateHolder))
        {
            return certificateHolder;
        }

        return _defaultCertificateHolder;
    }
}
